<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>分布式事务和分布式一致性协议 | klein blog</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/img/favicon.ico">
    <script data-ad-client="ca-pub-7828333725993554" async="async" src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
    <meta name="description" content="web前端技术博客,简洁至上,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.96b44d99.css" as="style"><link rel="preload" href="/assets/js/app.4d9c6fc1.js" as="script"><link rel="preload" href="/assets/js/2.edbbd412.js" as="script"><link rel="preload" href="/assets/js/6.649c6dce.js" as="script"><link rel="prefetch" href="/assets/js/10.42b2c55f.js"><link rel="prefetch" href="/assets/js/11.ded1a63e.js"><link rel="prefetch" href="/assets/js/12.4216cc3d.js"><link rel="prefetch" href="/assets/js/13.aaa65e73.js"><link rel="prefetch" href="/assets/js/14.996a0d92.js"><link rel="prefetch" href="/assets/js/15.207b2a40.js"><link rel="prefetch" href="/assets/js/16.a42f97bc.js"><link rel="prefetch" href="/assets/js/17.05d7250d.js"><link rel="prefetch" href="/assets/js/18.f970a06a.js"><link rel="prefetch" href="/assets/js/3.f8aba929.js"><link rel="prefetch" href="/assets/js/4.2f7feb84.js"><link rel="prefetch" href="/assets/js/5.1f9fc3c8.js"><link rel="prefetch" href="/assets/js/7.fa176c2b.js"><link rel="prefetch" href="/assets/js/8.714be39d.js"><link rel="prefetch" href="/assets/js/9.97aee9d0.js">
    <link rel="stylesheet" href="/assets/css/0.styles.96b44d99.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/EB-logo.png" alt="klein blog" class="logo"> <span class="site-name can-hide">klein blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="系统架构" class="dropdown-title"><a href="/system/" class="link-title">系统架构</a> <span class="title" style="display:none;">系统架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>系统架构</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/73fbb6/" aria-current="page" class="nav-link router-link-exact-active router-link-active">分布式理论</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/klein/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://dimg03.c-ctrip.com/images/100r0e00000077t0j045D_D_170_170_Q90.jpg"> <div class="blogger-info"><h3>Klein</h3> <span>klein xxxx</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="系统架构" class="dropdown-title"><a href="/system/" class="link-title">系统架构</a> <span class="title" style="display:none;">系统架构</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>系统架构</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/73fbb6/" aria-current="page" class="nav-link router-link-exact-active router-link-active">分布式理论</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><a href="/pages/beb6c0bd8a66cea6/" class="nav-link">收藏</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/klein/vuepress-theme-vdoing" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>分布式理论</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/73fbb6/" aria-current="page" class="active sidebar-link">分布式事务和分布式一致性协议</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/6c8981/" class="sidebar-link">分布式选举算法</a></li></ul></section></li></ul> <div class="sidebar-slot sidebar-slot-bottom"><!-- 正方形 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="3508773082"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div></aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-1cd794fe><div class="articleInfo" data-v-1cd794fe><ul class="breadcrumbs" data-v-1cd794fe><li data-v-1cd794fe><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-1cd794fe></a></li> <li data-v-1cd794fe><a href="/system" title="系统架构-目录页" data-v-1cd794fe>系统架构</a></li> <li data-v-1cd794fe><a href="/system/#分布式理论" title="系统架构#分布式理论" data-v-1cd794fe>分布式理论</a></li> <!----></ul> <div class="info" data-v-1cd794fe><div title="作者" class="author iconfont icon-touxiang" data-v-1cd794fe><a href="https://github.com/klein" target="_blank" title="作者" class="beLink" data-v-1cd794fe>klein</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-1cd794fe><a href="javascript:;" data-v-1cd794fe>2021-06-28</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABH1JREFUSA3tVl1oHFUUPmdmd2ltklqbpJDiNnXFmgbFktho7YMPNiJSSZM0+CAYSkUELVhM6YuwIPpgoOKDqOBDC0XE2CQoNtQXBUFTTcCi+Wlh1V2TQExsUzcltd3M9Tt3ZjZzZ2fT+OJTL8yeM+eee757fmeJbq//KQL8X3DUSFOcfr7cRsRtxNQMWueeVzOkaITIGqQHNg5y8+jNW9ldM7A6nTpAjuolUikAwq7CE3WcM2RRDz+XGVgN3FptU/aUSlvq9Pa3iZ1+sgAqJyyAFqkipd9dqiwHF3P65YycLWc/6sqGrvoEoIp6DOFaX5h6+dnfjkWprwqsPk0dUGq5vySwDImC10KxFHgGL1SWoc92O3eVht09qdXNH11I2SsTsJYqMWzihqGMi+A+Garf3BAuuLI5oGlULyNfyB/HYNujwktOfRrMr5t77NmevqaUopx0grnKAyvVpmwUDB4x6FPXuGvYLTDwWsejwgtgkYKPqRJg8SV6xaiZ3ZTppGneS4yfH5/66fZSDHv+QZci/+h5c5UHtpy67JUqGppM0sh0Nc1dW6/N1W5Yoqat8/TU/VnadmdeW2PLLSyh0cvxBs3KbqTmwYPpxN4do/mzE8nEpvX/UMu2Wbp74zUAK5q6WkHns7V0eWkdPbPzd3rxkTGybadYySumVzhcaJFbs5UrEkQ/+CK8gF5dnh/6ciIZ73gwQ927L1IitoxKLXYP3SjYdOrHHfTZhRRlFyrorafPk20B3HPD1y2G3qKZME5Jcf3t/HUC13/8tSd++vqFveMUTwAUxSUFI1QekR1+bIze3D9MF2aq6cPvG72CgnldWCFqyRw3lwH8ZMerjTD9ElRO7Gv44wNpC90aASqGfVlz/Rx17srQ57/UU26hkhQqUB7dBR71WmzQhHUnblGmVOEw0jhbV1n9OlXUDCIRGaNV5Jp43N516fN7JmnTHdfp7Hgy0luO4aMhtkLL8Bi3bUWYvzh5Mn1dTxrL6QmGuRhGL/TiTTxRoEdTszSaq9GR0NGA3KdkOz3hqSV3MIDhQ5IVX/Ivx3umBti2es2h4eZby7x8br1rkf7Mo90AqC8aQ3sJeNzqFRu+vSANAQe3PL7l0HGOAdwDCeZYvNKeoZp1Qfs6Aipndh86HmFRi0LAnEO47wsqM6cdfjh3jBPUzhZy7nvlUfFsamED1VQt6aISHVymXZ/B2aCtIG8AI8xfobj2d3en1wWVhOeHELKmLQ1s211s88comkv4UCwWyF787mJdYXtNfhKAXVqnKTq8QZvGAGGOfaTo5pGZ/PwbUCr5+DPr/1J92JNHr9aOl/F3iI5+O1nfybsGxoimvZ3ViWSluDITw3P37mypheDIPY0tw7+O/5ApbkYw+zpfaUVu32Pi98+defdUhEpZkRFq0aqyNh9FuL9hpYbEm6iwi0z2REd09ZmyENEbuhjDWzKvZXTqKYaBIr3tt5kuPtQBZFvEUwHt60vfCNu41XsksH9Ij1BMMz1Y0OOunHNShFIP5868g5zeXmuLwL9T4b6Q2+KejgAAAABJRU5ErkJggg==">
          分布式事务和分布式一致性协议
        </h1> <div class="page-slot page-slot-top"><!-- 固定100% * 90px可显示，max-height:90px未见显示-->
     <ins class="adsbygoogle"
          style="display:inline-block;width:100%;max-height:90px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6625304284"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="theme-vdoing-content content__default"><p></p><div class="table-of-contents"><ul><li><a href="#一-分布式系统简介">一 分布式系统简介</a></li><li><a href="#二分布式系统常见概念">二分布式系统常见概念</a></li><li><a href="#三-分布式理论">三 分布式理论</a></li></ul></div><p></p> <h3 id="一-分布式系统简介"><a href="#一-分布式系统简介" class="header-anchor">#</a> 一 分布式系统简介</h3> <p>单机处理能力主要依靠CPU、内存、磁盘硬件资源，但是这些资源都会有自己的性能平静，随着系统的发展，应用系统往往需要承担高并发，高吞吐量，高可用等能力。单机满足不了现实需要。所以才诞生了众多的分布式系统。</p> <p>分布式系统是将应用分布在多台计算机上，彼此之间通过消息传递进行通信和协调的系统。分布式系统具有分布性、对等性、并发性、缺乏全局时钟、故障总会发生的特点，由于这些特点导致了分布式系统中的一致性难题</p> <h3 id="二分布式系统常见概念"><a href="#二分布式系统常见概念" class="header-anchor">#</a> 二分布式系统常见概念</h3> <p><strong>集群</strong></p> <blockquote><p>同一个业务，部署在多个服务器上共同承担外界的调用压力，可以解决单点问题。数据库层面的集群可以解决容错问题，其中一台服务器挂了，不会影响服务的正常访问。N台机器可以同时做同一件事，例如海量请求都来调用同一服务，单个服务处理不过来，可以将此服务部署到N个服务器上，这些服务器组成集群同时处理海量请求。</p></blockquote> <p><strong>分布式</strong></p> <blockquote><ul><li>将多个业务分开部署到不同机器上，每个业务服务相互隔离，分散了负载。同时也可也将每个业务单独部署成集群，这个业务集群可能操作相同的底层数据来源，例如读取配置，数据库，设置集中式缓存等，那这个服务和读取配置等操作之间的关系是分布式的。这样子就带来了分布式系统下常见的问题：数据一致性，分布式事物，以及锁竞争等。</li> <li>而对于被访问端（配置，数据库，缓存服务等），随着被并发访问的次数增加，负载越来越大，也可以部署成集群，将原本存储在一台服务器的数据分散到存储在多台服务器上，从而每台只存储少量的数据（分片存储），来提升写入和读取的性能。</li></ul></blockquote> <p><strong>节点</strong></p> <blockquote><p>节点是指一个可以独立按照分布式协议完成一组逻辑的程序 个体（可以认为集群中一台服务器是一个节点）。在具体的项目中，一个节点表示的是一个操作系统上的 进程。</p></blockquote> <p><strong>分片</strong>： 分片是指拆分数据为多份存储</p> <p><strong>副本</strong></p> <blockquote><p>副本(replica/copy)指在分布式系统中为数据或服务提供的冗 余。 数据副本指在不同的节点上持久化同一份数据，当出现某一个 节点的数据丢失时，可以从副本上读取到数据。数据副本是分 布式系统中解决数据丢失问题的唯一手段。服务副本表示多个节点提供相同的服务，通过主从关系来实现 服务的高可用方案 。同时带来了数据一致性问题</p></blockquote> <ul><li><strong>中间件</strong></li></ul> <blockquote><p>中间件位于操作系统提供的服务之外，又不属于应用，他是位 于应用和系统层之间为开发者方便的处理通信、输入输出的一 类软件，能够让用户关心自己应用的部分。</p></blockquote> <ul><li><strong>网络分区</strong></li></ul> <blockquote><p>当网络由于发生异常情况，导致分布式系统中部分节点之间的网络延时不断增大，最终导致组成分布式系统的所有节点中，只有部分节点之间能够正常通信，而另一些节点则不能----我们将这个现象称为网络分区。当网络分区出现时，分布式系统会出现局部小集群，在极端情况下，这些局部小集群会独立完成原本需要整个分布式系统才能完成的功能，包括对数据的事物处理，这就对分布式一致性提出了非常大的挑战</p></blockquote> <ul><li><strong>三态</strong></li></ul> <blockquote><p>分布式系统的每一次请求与响应，存在特有的三态概念，即成功、失败、超时。 在传统的单机系统中，应用程序在调用一个函数之后，能够得到一个非常明确的响应：成功或失败。而在分布式系统中，由于网络是不可靠的，虽然在绝大部分情况 下，网络通信也能够接受到成功或失败的响应，当时当网络出现异常的情况下，就可能会出现超时现象</p></blockquote> <h3 id="三-分布式理论"><a href="#三-分布式理论" class="header-anchor">#</a> 三 分布式理论</h3> <h4 id="_1-cap-定理"><a href="#_1-cap-定理" class="header-anchor">#</a> （1）CAP 定理</h4> <p><img src="/mdimg/9bc553bdb95741495e93a8a276c3ecde.png" alt="9bc553bdb95741495e93a8a276c3ecde.png"></p> <p>指的是在一个分布式系统中， Consistency（一致性）、 Availability（可用性）、Partition tolerance（分区容错性），这三个基本需求最多只能同时满足其中两项。</p> <ol><li><strong>一致性(C)</strong> 在分布式环境下，一致性是指数据在多个副本之间能否保持一致的特性</li> <li><strong>可用性(A)</strong> 可用性是指系统提供的服务必须一直处于可用的状态，在集群中一部分节点故障后，集群整体是否还能响应客户端的读写请求。（对数据更新具备高可用性）</li> <li><strong>分区容忍性（P）</strong> 分区相当于对通信的时限要求，系统如果不能在时限内达成数据一致性，就意味着发生了分区的情况，必须就当前操作在C和A之间做出选择。
|CA|放弃分区容错性，加强一致性和可用性，是传统的单机数据库的选择                                                             |
|AP|放弃一致性（这里说的一致性是强一致性），追求分区容错性和可用性，这是很多分布式系统设计时的选择，例如很多NoSQL系统就是如此|
|CP|放弃可用性，追求一致性和分区容错性，基本不会选择，网络问题会直接让整个系统不可用                                         |</li></ol> <h4 id="_2-base-理论"><a href="#_2-base-理论" class="header-anchor">#</a> （2）BASE 理论</h4> <p>BASE是 <strong>Basically Available（基本可用）+ Soft state（软状态）+ Eventually consistent（最终一致）</strong> 三个短语的简写组合，是由CAP理论发展而来，主要解决分布式系统中一致性和可用性之间的平衡问题。BASE理论的核心思想是：<strong>在无法做到数据强一致性的时候，捅过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致的，但最终达到一致状态</strong></p> <ul><li><strong>基本可用 Basically Available</strong>： 保证功能的部分可用，例如允许系统响应时间适当延长，允许系统系统降级使部分非核心功能不可用。但这绝不等价于系统不可用。</li> <li><strong>软状态Soft state</strong>：软状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时</li> <li><strong>最终一致性</strong>：最终一致性的本质是保证在一段时间以后节点的数据最终能够达到一致，而不需要实时保证系统数据的强一致性。</li></ul> <h4 id="_3-分布式数据一致性"><a href="#_3-分布式数据一致性" class="header-anchor">#</a> (3) 分布式数据一致性</h4> <p>所谓的分布式下数据一致性问题在计算机原理中也有体现，单核计算机升级为多核计算机 跟现在的单机系统升级为分布式系统所面临的问题有着异曲同工之妙，面临的问题是相同的，同样的解决方案也类似。</p> <p><strong>集群数据一致性问题：</strong></p> <ul><li><p>主从或副本之间数据如何同步</p></li> <li><p>转账业务中的扣款和存款需要保证一边减少一边增加了</p></li> <li><p>数据库缓存的双写</p></li></ul> <p>所谓分布一致性问题，是指在分布式环境中引入数据复制机制之后在对一个副本数据进行更新的时候，必须确保也能够更新其他的 副本，否则不同副本之间的数据将不一致。最直接办法就是阻塞写入动作直到所有服务器都写入完毕，他解决了一致性问题但是降低了系统写入的性能，在一个写很频繁的场景中会导致大量的写请求挤压，从而系统性能急剧下降。于是一致性级别出现了：
<strong>1. 强一致性</strong>：这种一致性级别是最符合用户直觉的，它要求系统写入什么，读出来的也会是什么，用户体验好，但实现起来往往对系统的性能影响大</p> <p><strong>2. 弱一致性</strong>：这种一致性级别约束了系统在写入成功后，不承诺立即可以读到写入的值，也不久承诺多久之后数据能够达到一致，但会尽可能地保证到某个时间级别（比如秒级别）后，数据能够达到一致状态</p> <p><strong>3. 最终一致性</strong>：最终一致性是弱一致性的一个特例，系统会保证在一定时间内，能够达到一个数据一致的状态。这里之所以将最终一致性单独提出来，是因为它是弱一致性中非常推崇的一种一致性模型，也是业界在大型分布式系统的数据一致性上比较推崇的模型</p> <h4 id="_4-分布式事务"><a href="#_4-分布式事务" class="header-anchor">#</a> (4) 分布式事务</h4> <p>事务是指组成事务的操作都正常执行的情况下方可提交，他将一个活动涉及到的所有操作纳入一个不可分割的单元。就是要么什么都不做，要做就要全部成功的机制。</p> <h5 id="_1-事物具有acid四个特性"><a href="#_1-事物具有acid四个特性" class="header-anchor">#</a> 1 事物具有ACID四个特性：</h5> <ol><li><strong>原子性（atomicity）</strong>：一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。</li> <li><strong>一致性（consistency）</strong>：事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。</li> <li><strong>隔离性（isolation）</strong>：一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。</li> <li><strong>持久性（durability）</strong>：持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响</li></ol> <h5 id="_2-数据库事务的四种隔离级别"><a href="#_2-数据库事务的四种隔离级别" class="header-anchor">#</a> 2 数据库事务的四种隔离级别</h5> <p><strong>隔离性所带来的问题：</strong></p> <ul><li><strong>脏读</strong>：脏读是指在一个事务处理过程里读取了另一个未提交的事务中的数据。</li> <li><strong>不可重复读</strong>：(针对数据修改)对于数据库中的某个数据，一个事务范围内多次查询却返回了不同的数据值，这是由于在查询间隔，被另一个事务修改并提交了。</li> <li><strong>幻读</strong>：（针对数据新增）幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。
<strong>MySQL数据库为我们提供的四种隔离级别：</strong></li></ul> <ol><li><strong>Read uncommitted 、读未提交</strong>：就是一个事务可以读取另一个未提交事务的数据。会造成脏读问题（读到了未提交的数据后来这个数据被回滚了，造成数据不准确）</li> <li><strong>Read committed 读提交</strong>：就是一个事务要等另一个事务提交后才能读取数据，能够解决脏读问题，但是不能解决不可重复读问题（一个事务第一次读到数据和第二次读到数据不一致，原因是在两次读取之间有别的事务修改了数据并提交了。</li> <li><strong>Repeatable read -重复读</strong>：就是在开始一个事务时时，不再允许修改操作。 可以解决不可重复读的问题，不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作；（程序员某一天去消费，花了2千元，然后他的妻子去查看他今天的消费记录（全表扫描FTS，妻子事务开启），看到确实是花了2千元，就在这个时候，程序员花了1万买了一部电脑，即新增INSERT了一条消费记录，并提交。当妻子打印程序员的消费记录清单时（妻子事务提交），发现花了1.2万元，似乎出现了幻觉，这就是幻读。）</li> <li><strong>Serializable 串行化读</strong>：Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。</li></ol> <blockquote><p>RR这是MYSQL InnoDB默认的隔离级别，其他数据库的默认隔离级别通常是RC，幻读和不可重复读区别在于 幻读针对得是插入Insert操作，不可重复读针对得是Update更新操作</p></blockquote> <h5 id="_3-mvcc多版本并发控制"><a href="#_3-mvcc多版本并发控制" class="header-anchor">#</a> 3 MVCC多版本并发控制</h5> <ul><li>MVCC，Multi-Version Concurrency Control，多版本并发控制。MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问。mvcc可以解决重复读的问题。</li> <li>在数据库数据被多个事务同时访问的时候可能会造成事务中数据不一致的情况发生，通过加锁方式，让所有的读等待写工作完成在进行可以解决此问题，但是这样效率会很差。Mysql的大多数事务型存储引擎实现的都不是简单的行级锁。基于提升并发性能的考虑，它们一般都同时实现了多版本并发控制（MVCC）。</li> <li>MVCC的实现，是通过保存数据在某一个时间点的快照来实现的。因此每一个事务无论执行多长时间看到的数据，都是一样的。在事务隔离级别为RC和RR级别下， InnnoDB存储引擎使用的才是多版本并发控制。然而，对于快照数据的定义却不相同。在RC事务隔离级别下，对于快照数据（undo端数据），总是读取被锁定行的最新的一份快照数据。而在RR事务隔离级别下，对于快照数据，多版本并发控制总是读取事务开始时的行数据。</li></ul> <h5 id="_4-分布式事务-2"><a href="#_4-分布式事务-2" class="header-anchor">#</a> 4 分布式事务</h5> <p>分布式事务是指会涉及到操作多个数据库的事务，其实就是将对同一库事务的概念扩大到了对多个库的事务。目的是为了保证分布式系统中的数据一致性。分布式事务处理的关键是：需要记录事务在任何节点所做的所有动作； 事务进行的所有操作要么全部提交，要么全部回滚。</p> <p><strong>如何解决分布式事务问题：</strong></p> <h5 id="_1-xa-规范"><a href="#_1-xa-规范" class="header-anchor">#</a> （1）XA 规范</h5> <p>XA规范是由 X/Open组织（即现在的 Open Group ）定义的分布式事务处理模型,XA规范定义了交易中间件与数据库之间的接口规范（即接口函数），交易中间件用它来通知数据库事务的开始、结束以及提交、回滚等。而XA接口函数由数据库厂商提供。二阶提交协议和三阶提交协议就是基于XA规范提出的其中，二阶段提交就是实现XA分布式事务的关键。它包括四个角色 ：</p> <ol><li>包括应用程序（AP）：应用程序</li> <li>事务管理器（TM）: 例如交易中间件，是必需的，由它通知和协调相关数据库的提交或回滚</li> <li>资源管理器（RM）：例如数据库，一个数据库只将其自己所做的操作（可恢复）影射到全局事务中</li> <li>通信资源管理器（CRM）：消息中间件
<strong>XA规范的流程，大致如图所示：</strong></li></ol> <p><img src="/mdimg/22b1e1faf63c700801cc7fe24119fe53.png" alt="22b1e1faf63c700801cc7fe24119fe53.png"></p> <p><strong>XA规范编程规范</strong></p> <blockquote><ol><li>配置TM，给TM注册RM作为数据源。其中，一个TM可以注册多个RM。</li> <li>AP向TM发起一个全局事务。这时，TM会发送一个XID（全局事务ID）通知各个RM。</li> <li>AP从TM获取资源管理器的代理（例如：使用JTA接口，从TM管理的上下文中，获取出这个TM所管理的RM的JDBC连接或JMS连接）。</li> <li>AP通过从TM中获取的连接，间接操作RM进行业务操作。TM在每次AP操作时把XID传递给RM，RM正是通过这个XID关联来操作和事务的关系的。</li> <li>AP结束全局事务时，TM会通知RM全局事务结束。开始二段提交，也就是prepare - commit的过程。</li></ol></blockquote> <p>通常把一个数据库内部的事务处理作为本地事务看待，分布式事务处理的对象是多个事务共同完成一个工作，被称作全局事务。</p> <p>例如一个分布式事务中可能更新几个不同的数据库。对数据库的操作发生在系统的各处但必须全部被提交或回滚。此时一个数据库对自己内部所做操作的提交不仅依赖本身操作是否成功，还要依赖与全局事务相关的其它数据库的操作是否成功，如果任一数据库的任一操作失败，则参与此事务的所有数据库所做的所有操作都必须回滚。一般情况下，某一数据库无法知道其它数据库在做什么，因此，在一个 DTP 环境中，交易中间件是必需的，由它通知和协调相关数据库的提交或回滚。而一个数据库只将其自己所做的操作（可恢复）影射到全局事务中。</p> <h5 id="_2-分布式事务协议"><a href="#_2-分布式事务协议" class="header-anchor">#</a> （2）分布式事务协议</h5> <p>分布式系统的一个难点是如何保证架构下多个节点在进行事务性操作的时候保持一致性,为了解决一致性问题提出了很多协议和算法，比较著名的分布式一致性协议有二阶提交协议（Two Phase Commitment Protocol）、三阶提交协议（Three Phase Commitment Protocol）和 Paxos算法。</p> <p>二阶段提交和三阶段提交是根据XA规范衍生出来的，是XA规范实现分布式事务的关键，两阶段提交保证了分布式事物的原子性。</p> <h5 id="两阶段提交协议-2pc"><a href="#两阶段提交协议-2pc" class="header-anchor">#</a> 两阶段提交协议 2PC</h5> <p><strong>二阶段提交的算法思路可以概括为：每个参与者将操作成败通知协调者，再由协调者根据所有参与者的反馈情况，决定各参与者是否要提交操作还是中止操作</strong></p> <p>所谓的两个阶段是指：<strong>第一阶段：准备阶段(投票阶段) 和 第二阶段：提交阶段（执行阶段)</strong></p> <p>参与者将操作的成败都反馈给协调者事务管理器TM，再有协调者根据所有反馈这的情况决定下一步是提交还是中止。两阶段提交主要保证了分布式事务的原子性：即所有结点要么全做要么全不做</p> <p><img src="/mdimg/4ea620e19469b0bbd5daa456b59b91c5.png" alt="4ea620e19469b0bbd5daa456b59b91c5.png"></p> <p><strong>阶段一：提交事务请求（投票）</strong></p> <ol><li>协调者向参与者发起事务询问，并开始等到参与者响应</li> <li>参与者尝试执行事务，并把所有操作和准备都尽可能完成，并将事务的执行结果反馈给协调者。</li></ol> <p>阶段一类似于参与者再给协调者进行事务投票，各参与者表明是否需要继续执行下一步的提交操作。所以被称为投票阶段。这个时候参与者的资源是被事务锁定状态，处于阻塞中。直到提交、中止完成。
<strong>阶段二：执行事务提交</strong></p> <p>协调者会根据阶段一的投票情况来决定最终是否可以进行事务提交/中断操作。</p> <p><strong>事务提交：</strong></p> <p><img src="/mdimg/c59877e5ecd836deb0de3121a2f7bfcd.png" alt="c59877e5ecd836deb0de3121a2f7bfcd.png"></p> <p><strong>事务中断：</strong></p> <p><img src="/mdimg/2db5625f8ec77e165876d32916d7e362.png" alt="2db5625f8ec77e165876d32916d7e362.png"></p> <p><strong>2PC 缺点</strong></p> <ul><li><p><strong>同步阻塞问题</strong> 执行过程中，所有参与节点都是事务阻塞型的。参与者占用共享资源时，其他第三方节点就不能访问此资源。</p></li> <li><p><strong>单点故障</strong> 由于协调者的重要性，一旦协调者发生故障。参与者会一直阻塞下去。尤其在第二阶段，协调者发生故障，那么所有的参与者还都处于锁定事务资源的状态中，而无法继续完成事务操作。（如果是协调者挂掉，可以重新选举一个协调者，但是无法解决因为协调者宕机导致的参与者处于阻塞状态的问题）</p></li> <li><p><strong>数据不一致</strong>。在阶段二中，当协调者向参与者发送commit请求之后，协调者发生了故障，还有可能导致只有一部分参与者接受到了commit请求。而在这部分参与者接到commit请求之后就会执行commit操作。但是其他部分未接到commit请求的机器则无法执行事务提交。于是整个分布式系统便出现了数据部一致性的现象。最坏的情况时所有参与者都没接收到请求，则就出现了上面的<strong>单点故障</strong></p></li></ul> <h5 id="三阶段提交协议-3pc"><a href="#三阶段提交协议-3pc" class="header-anchor">#</a> 三阶段提交协议 3PC</h5> <p><img src="/mdimg/f0b75dc60176bd9bf3c2c51b0fc4d3f4.png" alt="f0b75dc60176bd9bf3c2c51b0fc4d3f4.png"></p> <ol><li>同时在协调者和参与者中都引入超时机制。</li> <li>在第一阶段和第二阶段中插入一个准备阶段。这样三阶段提交就有CanCommit、PreCommit、DoCommit三个阶段。保证了在最后提交阶段之前各参与节点的状态是一致的。
相对于2PC，3PC加入的超时机制解决了单点故障，并减少了阻塞，因为一旦参与者无法及时收到协调者的信息他会默认执行commit操作，而不会一直持有事务资源并处于阻塞状态。但是它无法解决数据一致性问题，因为由于网络原因，协调者发送的abort中断响应没有及时被参与者接收到，那么参与者在等待超时之后执行了commit操作。这样就和其他接到abort中断命令并执行回滚的参与者之间存在数据不一致的情况。</li></ol> <p>三阶段缺点：数据不一致：参与者收到preCommit请求，此时如果出现网络分区，协调者与参与者之间无法进行正常网络通信，参与者在超时之后还是会进行事务提交，就会出现数据不一致</p> <p><em>无论是二阶段提交还是三阶段提交都无法彻底解决分布式的一致性问题，彻底解决需要使用Paxos算法。Google Chubby的作者Mike Burrows说过，世上只有一种一致性算法，那就是Paxos，所有其他一致性算法都是Paxos算法的不完整版</em></p> <h5 id="paxos分布式一致性算法"><a href="#paxos分布式一致性算法" class="header-anchor">#</a> Paxos分布式一致性算法</h5> <p>Paxos是试图对各Server上的状态进行全局编号，如果能编号成功，那么所有操作都按照编号顺序执行，一致性就不言而喻。当Cluster中的Server都接收了一些数据，如何进行编号？就是表决，让所有的Server进行表决，看哪个Server上的哪个数据应该排第一，哪个排第二...，只要多数Server同意某个数据该排第几，那就排第几。</p> <p>很显然，为了给每个数据唯一编号，每次表决只能产生一个数据，否则表决就没有任何意义。Paxos的算法的所有精力都放在如何在一次表决只产生一个数据。再进一步，我们称表决的数据叫Value，Paxos算法的核心和精华就是确保每次表决只产生一个Value。</p> <p>很多中间件根据paxos理论衍生出来的自己的leader选举算法</p> <p>zk的leader的选举，使用的是基于paxos算法的ZAB协议，redis的leader选举，使用的是基于paxos算法的raft算法</p> <h5 id="_5-分布式事务的解决方案"><a href="#_5-分布式事务的解决方案" class="header-anchor">#</a> （5）分布式事务的解决方案</h5> <p><strong>1. 全局事务 - 强一致性:</strong> 2pc 3pc</p> <p><strong>2. 本地消息表（异步确保） - 最终一致性</strong></p> <p>本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay</p> <p><img src="/mdimg/77f55c33c6674bed8ab0b1a8e5db1ccd.png" alt="77f55c33c6674bed8ab0b1a8e5db1ccd.png"></p> <p><strong>消息生产方：</strong> 在业务库中同时新建一个消息表来记录消息的状态，业务表写入数据的时候消息表也写入一条消息数据，二者在一个事务里面。然后消息投送到MQ中，发给消费者。如果此时消息发送失败，走MQ的重发逻辑。</p> <p><strong>消息消费方：</strong> 接受业务消息并处理，如果本地事务处理成功则修改消息表状态为成功，流程结束。如果本地事务失败则修改消息表状态为失败，根据具体失败情况来决定是重试还是直接回滚。（此时需要一个定时任务去扫消息表，来处理回滚或重试动作）注意消息消费需要保证幂等，避免同一条消息被多次消费。</p> <p><strong>消息表怎么创建呢？</strong> 这个表应该包括这些字段： id, biz_id, biz_type, msg, msg_result, msg_desc,atime,try_count。分别表示uuid，业务id，业务类型，消息内容，消息结果（成功或失败），消息描述，创建时间，重试次数， 其中biz_id，msg_desc字段是可选的。</p> <p><strong>栗子：</strong></p> <p><img src="/mdimg/6ad14ba47da9f48ce86ae06225e1dc2c.png" alt="6ad14ba47da9f48ce86ae06225e1dc2c.png"></p> <p><img src="/mdimg/2009438cf90f58cf027e0672ad375668.png" alt="2009438cf90f58cf027e0672ad375668.png"></p> <p><strong>3. 最大努力通知</strong></p> <p><img src="/mdimg/d7cd107729ae820779de05a1243c336c.png" alt="d7cd107729ae820779de05a1243c336c.png"></p> <p>最大努力通知方案类似于本地消息表方案，他要求消息发送方必须包含消息重发机制，消息消费方要确保消息能被正确消费，如果消费失败则定期校对再次重试消费。主要是对mq的事务要求比较大。最大努力通知型事务”是为解决跨网络、跨服务，夸企业之间的事物数据一致性方案。</p> <p>相比于上一方案，它达到数据一致性的周期较长，而且还需要在上游系统中实现消息重试发布机制</p> <p><strong>4. MQ 事务消息可以支持分布式事务</strong></p> <p>这种方式主要是通过选取支持事务的消息队列中间件来确保分布式事务的数据一致性。确保消息成功投递和消费。现在目前较为主流的MQ，比如ActiveMQ、RabbitMQ、Kafka、RocketMQ等，只有RocketMQ支持事务消息。可以考虑自己实现</p> <p><img src="/mdimg/d86b9467b0ef2a0a62ab96ee02857741.png" alt="d86b9467b0ef2a0a62ab96ee02857741.png"></p> <p><strong>确保消息成功发出：</strong></p> <p>由于传统的处理方式无法解决消息生成者本地事务处理成功与消息发送成功两者的一致性问题，因此事务消息就诞生了，它实现了消息生成者本地事务与消息发送的原子性，保证了消息生成者本地事务处理成功与消息发送成功的最终一致性问题。</p> <p><img src="/mdimg/f6aa37b79ae0f7583d7567ff3c77f3b3.png" alt="f6aa37b79ae0f7583d7567ff3c77f3b3.png"></p> <p>在业务方法内要想消息队列提交两次请求，一次发送消息和一次确认消息。</p> <ol><li>第一阶段：发送Prepared消息，会拿到消息的地址。</li> <li>第二阶段：执行本地事务</li> <li>第三阶段：确认消息，通过第一阶段拿到的地址去访问消息，并修改状态
如果确认消息发送失败了RocketMQ会定期扫描消息集群中的事务消息，这时候发现了Prepared消息，它会向消息发送者确认，所以生产方需要实现一个check接口，RocketMQ会根据发送端设置的策略来决定是回滚还是继续发送确认消息。这样就保证了消息发送与本地事务同时成功或同时失败。</li></ol> <p><strong>5. TCC - 最终一致性</strong></p> <p>TCC 其实就是采用的补偿机制，进行自行研发。其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：</p> <ol><li>Try 阶段主要是对业务系统做检测及资源预留</li> <li>Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。</li> <li>Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。
举个简单的例子如果你用100元买了一瓶水， Try阶段:你需要向你的钱包检查是否够100元并锁住这100元，水也是一样的。如果有一个失败，则进行cancel(释放这100元和这一瓶水)，如果cancel失败不论什么失败都进行重试cancel，所以需要保持幂等。如果都成功，则进行confirm,确认这100元扣，和这一瓶水被卖，如果confirm失败无论什么失败则重试(会依靠活动日志进行重试)</li></ol> <p>对于TCC来说适合一些:强隔离性，严格一致性要求的活动业务。执行时间较短的业务，实现参考: https://github.com/liuyangming/ByteTCC/</p> <p><img src="/mdimg/a1b29fa503be1f567eb0f97191467387.png" alt="a1b29fa503be1f567eb0f97191467387.png"></p> <ul><li>解决了协调者单点，由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。</li> <li>同步阻塞:引入超时，超时后进行补偿，并且不会锁定整个资源，将资源转换为业务逻辑形式，粒度变小。</li> <li>数据一致性，有了补偿机制之后，由业务活动管理器控制一致性
<strong>6. Sagas 事务模型</strong></li></ul> <p>该模型其核心思想就是拆分分布式系统中的长事务为多个短事务，或者叫多个本地事务，然后由 Sagas 工作流引擎负责协调，如果整个流程正常结束，那么就算是业务成功完成，如果在这过程中实现失败，那么Sagas工作流引擎就会以相反的顺序调用补偿操作，重新进行业务回滚。</p> <p><strong>选择建议：</strong></p> <p>在面临数据一致性问题的时候，首先要从业务需求的角度出发，确定我们对于一致性模型的接受程度，再通过具体场景来决定解决方案，对购物转账等电商和金融业务，中间件层的2PC最大问题在于业务不可见，一旦出现不可抗力或意想不到的一致性破坏，如数据节点永久性宕机，业务难以根据2PC的日志进行补偿。金融场景下，数据一致性是命根，业务需要对数据有百分之百的掌控力，建议使用TCC这类分布式事务模型，或基于消息队列的柔性事务框架，这两种方案都在业务层实现，业务开发者具有足够掌控力 https://www.cnblogs.com/kaleidoscope/p/9627573.html</p></div></div> <div class="page-slot page-slot-bottom"><!-- 横向自适应 -->
      <ins class="adsbygoogle"
          style="display:block"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="6620245489"
          data-ad-format="auto"
          data-full-width-responsive="true"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/klein/vuepress-theme-vdoing/edit/master/docs/01.系统架构/01.分布式理论/01.分布式事务和分布式一致性协议.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/06/28, 18:53:13</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/pages/6c8981/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">分布式选举算法</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/pages/6c8981/">分布式选举算法</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/6c8981/"><div>分布式选举算法</div></a> <span>06-28</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/cd8bde/"><div>拥抱生活，拥抱快乐</div></a> <span>06-26</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/f2e63f/"><div>你知道的越多，不知道的也就越多</div></a> <span>05-06</span></dt></dl> <dl><dd></dd> <dt><a href="/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="mailto:919691653@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/xxx" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=123456" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2021-2021
    <span>klein | <a href="xxxx/LICENSE" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <div class="custom-html-window custom-html-window-rb" style="display:;"><div class="custom-wrapper"><i class="close-but">×</i> <div><!-- 固定160*160px -->
      <ins class="adsbygoogle"
          style="display:inline-block;max-width:160px;max-height:160px"
          data-ad-client="ca-pub-7828333725993554"
          data-ad-slot="8377369658"></ins>
      <script>
          (adsbygoogle = window.adsbygoogle || []).push({});
      </script>
      </div></div></div></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.4d9c6fc1.js" defer></script><script src="/assets/js/2.edbbd412.js" defer></script><script src="/assets/js/6.649c6dce.js" defer></script>
  </body>
</html>